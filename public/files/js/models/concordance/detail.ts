/*
 * Copyright (c) 2016 Charles University, Faculty of Arts,
 *                    Institute of the Czech National Corpus
 * Copyright (c) 2016 Tomas Machalek <tomas.machalek@gmail.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; version 2
 * dated June, 1991.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

import { IFullActionControl, StatefulModel } from 'kombo';
import { Observable, of as rxOf, forkJoin } from 'rxjs';
import { tap, map } from 'rxjs/operators';
import { Color, List, pipe, Dict, HTTP, tuple } from 'cnc-tskit';

import * as PluginInterfaces from '../../types/plugins';
import { PageModel } from '../../app/page';
import { AudioPlayer, PlayerStatus } from './media';
import { Actions as ViewOptionsActions } from '../options/actions';
import { Actions } from './actions';
import { AudioPlayerActions, DetailExpandPositions, WideCtx, WideCtxArgs } from './common';

/**
 *
 */
export type ConcDetailText = Array<{str:string; class:string}>;


/**
 *
 */
export interface Speech {
    text:ConcDetailText;
    speakerId:string;
    segments:Array<string>;
    colorCode:Color.RGBA;
    metadata:{[ident:string]:string};
}

/**
 * Note: A single speech line contains an array of
 * simultaneous speeches (i.e. if two people speak
 * at the same time then the array contains two items).
 */
export type SpeechLine = Array<Speech>;

export type SpeechLines = Array<SpeechLine>;


type ExpandArgs = [number, number];


export interface SpeechOptions {
    speakerIdAttr:[string, string];
    speechSegment:[string, string];
    speechAttrs:Array<string>;
    speechOverlapAttr:[string, string]|null;
    speechOverlapVal:string;
}

export interface ConcDetailModelState {

    concDetail:ConcDetailText;

    expandLeftArgs:Array<ExpandArgs>;

    expandRightArgs:Array<ExpandArgs>;

    corpusId:string;

    kwicTokenNum:number;

    tokenConnectData:PluginInterfaces.TokenConnect.TCData;

    kwicLength:number;

    lineIdx:number;

    wholeDocumentLoaded:boolean;

    structCtx:string;

    speechOpts:SpeechOptions;

    speechAttrs:Array<string>;

    speechDetail:SpeechLines;

    playingRowIdx:number;

    speakerColors:Array<Color.RGBA>;

    wideCtxGlobals:WideCtxArgs;

    spkOverlapMode:string;

    /**
     * Either 'default' or 'speech'.
     * An initial mode is inferred from speechOpts
     * (see constructor).
     */
    mode:string;

    /**
     * Speaker colors attachments must survive context expansion.
     * Otherwise it would confusing if e.g. green speaker '01'
     * changed into red one after a context expasion due to
     * some new incoming or outcoming users.
     */
    speakerColorsAttachments:{[ident:string]:Color.RGBA};

    isBusy:boolean;

    tokenConnectIsBusy:boolean;

    /**
     * Currently expanded side. In case the model is not busy the
     * value represent last expanded side (it is not reset after expansion).
     * Values: 'left', 'right' or a custom value generated by TC plugin
     */
    expandingSide:DetailExpandPositions|null;

    audioPlayerStatus:PlayerStatus;
}

/**
 * A model providing access to a detailed/extended kwic information.
 */
export class ConcDetailModel extends StatefulModel<ConcDetailModelState> {

    private static SPK_LABEL_OPACITY:number = 0.8;

    private static ATTR_NAME_ALLOWED_CHARS:string = 'a-zA-Z0-9_';

    private static SPK_OVERLAP_MODE_FULL:string = 'full';

    private static SPK_OVERLAP_MODE_SIMPLE:string = 'simple';

    static AUDIO_PLAYER_ID:string = 'detailPlayer';

    private readonly layoutModel:PageModel;

    private readonly audioPlayer:AudioPlayer;

    private readonly tokenConnectPlg:PluginInterfaces.TokenConnect.IPlugin;


    constructor(
        layoutModel:PageModel,
        dispatcher:IFullActionControl,
        structCtx:string,
        speechOpts:SpeechOptions,
        wideCtxGlobals:WideCtxArgs,
        tokenConnectPlg:PluginInterfaces.TokenConnect.IPlugin
    ) {
        super(
            dispatcher,
            {
                structCtx,
                speechOpts,
                mode: speechOpts.speakerIdAttr ? 'speech' : 'default',
                speechAttrs: speechOpts.speechAttrs,
                wideCtxGlobals,
                lineIdx: null,
                playingRowIdx: -1,
                wholeDocumentLoaded: false,
                speakerColors: List.map(
                    item => Color.importColor(ConcDetailModel.SPK_LABEL_OPACITY, item),
                    ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b',
                    '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'] // TODO
                ),
                speakerColorsAttachments: {},
                spkOverlapMode: (speechOpts.speechOverlapAttr || [])[1] ?
                        ConcDetailModel.SPK_OVERLAP_MODE_FULL :
                        ConcDetailModel.SPK_OVERLAP_MODE_SIMPLE,
                expandLeftArgs: [],
                expandRightArgs: [],
                tokenConnectData: {
                    token: null,
                    renders: []
                },
                concDetail: [],
                speechDetail: [],
                isBusy: false,
                tokenConnectIsBusy: false,
                corpusId: layoutModel.getCorpusIdent().id,
                expandingSide: null,
                kwicLength: 1,
                kwicTokenNum: -1,
                audioPlayerStatus: null
            }
        );
        this.layoutModel = layoutModel;
        this.tokenConnectPlg = tokenConnectPlg;
        this.audioPlayer = new AudioPlayer(
            this.layoutModel.createStaticUrl('misc/soundmanager2/'),
            () => {
                this.changeState(state => {
                    state.audioPlayerStatus = this.audioPlayer.getStatus()
                });
            },
            () => {
                this.handlePlayerControls('stop');
            },
            () => {
                this.audioPlayer.stop();
                this.changeState(state => {
                    state.audioPlayerStatus = this.audioPlayer.getStatus()
                });
                this.layoutModel.showMessage('error',
                        this.layoutModel.translate('concview__failed_to_play_audio'));
            },
            () => {
                this.changeState(state => {
                    state.audioPlayerStatus = this.audioPlayer.getStatus()
                });
            }
        );

        this.addActionHandler<typeof Actions.ExpandKwicDetail>(
            Actions.ExpandKwicDetail.name,
            action => {


                this.changeState(state => {
                    state.expandingSide = action.payload.position;
                    state.tokenConnectIsBusy = true;
                    state.isBusy = true;
                });

                forkJoin([
                    this.loadTokenConnect(
                        this.state.corpusId,
                        this.state.kwicTokenNum,
                        1,
                        this.state.lineIdx,
                        action.payload.position
                    ),
                    this.loadConcDetail(
                        [],
                        action.payload.position
                    )
                ]).subscribe({
                    next: () => {
                        this.changeState(state => {
                            state.isBusy = false;
                            state.tokenConnectIsBusy = false;
                            state.expandingSide = null;
                        });
                    },
                    error: err => {
                        this.changeState(state => {
                            state.isBusy = false;
                            state.tokenConnectIsBusy = false;
                            state.expandingSide = null;
                        });
                        this.layoutModel.showMessage('error', err);
                    }
                });
            }
        );

        this.addActionHandler<typeof Actions.ShowKwicDetail>(
            Actions.ShowKwicDetail.name,
            action => {
                this.changeState(state => {
                    state.isBusy = true;
                    state.tokenConnectIsBusy = true;
                    state.expandLeftArgs = Array<ExpandArgs>();
                    state.expandRightArgs = Array<ExpandArgs>();
                    state.corpusId = action.payload.corpusId;
                    state.kwicTokenNum = action.payload.tokenNumber;
                    state.kwicLength = action.payload.kwicLength;
                    state.lineIdx = action.payload.lineIdx;
                    state.wholeDocumentLoaded = false;
                });
                forkJoin([
                    this.state.mode === 'speech' ?
                        this.loadSpeechDetail(
                            this.state.expandLeftArgs.length > 1 &&
                            this.state.expandRightArgs.length > 1 ? 'reload' : null
                        ) :
                        this.loadConcDetail(
                            [],
                            this.state.expandLeftArgs.length > 1 &&
                                    this.state.expandRightArgs.length > 1 ? 'reload' : null
                        ),
                    this.loadTokenConnect(
                        action.payload.corpusId,
                        action.payload.tokenNumber,
                        action.payload.kwicLength,
                        action.payload.lineIdx,
                        'reload'
                    )

                ]).subscribe({
                    next: () => {
                        this.changeState(state => {
                            state.isBusy = false;
                            state.tokenConnectIsBusy = false;
                        });
                    },
                    error: err => {
                        this.changeState(state => {
                            state.isBusy = false;
                            state.tokenConnectIsBusy = false;
                        });
                        this.layoutModel.showMessage('error', err);
                    }
                });
            }
        );

        this.addActionHandler<typeof Actions.ShowTokenDetail>(
            Actions.ShowTokenDetail.name,
            action => {
                this.changeState(state => {
                    this.resetKwicDetail(state);
                    this.resetTokenConnect(state);
                    state.tokenConnectIsBusy = true;
                });
                this.loadTokenConnect(
                    action.payload.corpusId,
                    action.payload.tokenNumber,
                    1,
                    action.payload.lineIdx,
                    'reload'

                ).subscribe({
                    next: () => {
                        this.changeState(state => {
                            state.tokenConnectIsBusy = false;
                        });
                    },
                    error: err => {
                        this.changeState(state => {
                            state.tokenConnectIsBusy = false;
                        });
                        this.layoutModel.showMessage('error', err);
                    }
                });
            }
        );


        this.addActionHandler<typeof Actions.ShowWholeDocument>(
            Actions.ShowWholeDocument.name,
            action => {
                this.loadWholeDocument().subscribe({
                    next: () => {
                        this.emitChange();
                    },
                    error: err => {
                        this.layoutModel.showMessage('error', err);
                    }
                });
            }
        );

        this.addActionHandler<typeof Actions.ShowSpeechDetail>(
            Actions.ShowSpeechDetail.name,
            action => {
                this.changeState(state => {
                    state.mode = 'speech';
                    state.expandLeftArgs = [];
                    state.expandRightArgs = [];
                    state.speakerColorsAttachments = {};
                    state.isBusy = true;
                });
                this.loadSpeechDetail(this.state.expandLeftArgs.length > 1 &&
                            this.state.expandRightArgs.length > 1 ? 'reload' : null
                ).subscribe({
                    next: () => {
                        this.changeState(state => {
                            state.isBusy = false;
                        });
                    },
                    error: err => {
                        this.changeState(state => {
                            state.isBusy = false;
                        });
                        this.layoutModel.showMessage('error', err);
                    }
                });
            }
        );

        this.addActionHandler<typeof Actions.ExpandSpeechDetail>(
            Actions.ExpandSpeechDetail.name,
            action => {
                this.changeState(state => {
                    state.expandingSide = action.payload.position;
                    state.isBusy = true;
                });
                this.loadSpeechDetail(action.payload.position).subscribe(
                    () => {
                        this.changeState(state => {
                            state.isBusy = false;
                        });
                    },
                    (err) => {
                        this.changeState(state => {
                            state.isBusy = false;
                        });
                        this.layoutModel.showMessage('error', err);
                    }
                );
            }
        );

        this.addActionHandler<typeof Actions.DetailSwitchMode>(
            Actions.DetailSwitchMode.name,
            action => {
                (() => {
                    if (action.payload.value === 'default') {
                        this.changeState(state => {
                            state.mode = 'default';
                            state.expandingSide = null;
                            state.concDetail = [];
                            state.isBusy = true;
                        });
                        return this.reloadConcDetail();

                    } else if (action.payload.value === 'speech') {
                        this.changeState(state => {
                            state.mode = 'speech';
                            state.speakerColorsAttachments = {};
                            state.expandingSide = null;
                            state.concDetail = [];
                            state.isBusy = true;
                        });
                        return this.loadSpeechDetail();

                    } else {
                        this.changeState(state => {
                            state.mode = action.payload.value;
                            state.expandingSide = null;
                            state.concDetail = [];
                            state.isBusy = true;
                        });
                        return rxOf(null);
                    }
                })().subscribe({
                    next: () => {
                        this.changeState(state => {
                            state.isBusy = false;
                        });
                    },
                    error: err => {
                        this.changeState(state => {
                            state.isBusy = false;
                        });
                        this.layoutModel.showMessage('error', err);
                    }
                });
            }
        );

        this.addActionHandler<typeof Actions.ResetDetail, typeof Actions.ShowRefDetail>(
            [
                Actions.ResetDetail.name,
                Actions.ShowRefDetail.name
            ],
            action => {
                this.changeState(state => {
                    this.resetKwicDetail(state);
                    this.resetTokenConnect(state);
                });
            }
        );

        this.addActionHandler<typeof Actions.PlaySpeech>(
            Actions.PlaySpeech.name,
            action => {
                if (this.state.playingRowIdx > -1) {
                    this.changeState(state => {
                        state.playingRowIdx = null;
                    });
                    this.audioPlayer.stop();
                }
                this.changeState(state => {
                    state.playingRowIdx = action.payload.rowIdx;
                });
                const itemsToPlay = List.map(
                        item => this.layoutModel.createActionUrl(
                            `audio?corpname=${this.state.corpusId}&chunk=${item}`),
                        action.payload.segments
                );
                const waveformSources = List.map(
                    item => this.layoutModel.createActionUrl(
                        `audio_waveform?corpname=${this.state.corpusId}&chunk=${item}`),
                    action.payload.segments
                );
                if (itemsToPlay.length > 0) {
                    this.audioPlayer.start(itemsToPlay, waveformSources);

                } else {
                    this.changeState(state => {
                        state.playingRowIdx = -1;
                    });
                    this.layoutModel.showMessage('error',
                            this.layoutModel.translate('concview__nothing_to_play'));
                }
            }
        );

        this.addActionSubtypeHandler<typeof Actions.AudioPlayerClickControl>(
            Actions.AudioPlayerClickControl.name,
            action => action.payload.playerId === ConcDetailModel.AUDIO_PLAYER_ID,
            action => {
                this.handlePlayerControls(action.payload.action);
            }
        );

        this.addActionSubtypeHandler<typeof Actions.AudioPlayerSetPosition>(
            Actions.AudioPlayerSetPosition.name,
            action => action.payload.playerId === ConcDetailModel.AUDIO_PLAYER_ID,
            action => {
                this.audioPlayer.setPosition(action.payload.offset);
                this.changeState(state => {
                    state.audioPlayerStatus = this.audioPlayer.getStatus()
                });
            }
        );

        this.addActionHandler<typeof Actions.AudioPlayersStop>(
            Actions.AudioPlayersStop.name,
            action => {
                this.handlePlayerControls('stop');
            }
        );

        this.addActionHandler<typeof ViewOptionsActions.SaveSettingsDone>(
            ViewOptionsActions.SaveSettingsDone.name,
            action => {
                this.changeState(state => {
                    state.wideCtxGlobals = action.payload.widectxGlobals;
                });
            }
        );
    }

    private resetKwicDetail(state:ConcDetailModelState):void {
        if (state.lineIdx !== null) {
            state.lineIdx = null;
            state.corpusId = null;
            state.kwicTokenNum = null;
            state.kwicLength = null;
            state.wholeDocumentLoaded = false;
            state.expandLeftArgs = [];
            state.expandRightArgs = [];
            state.speakerColorsAttachments = {};
            state.concDetail = [];
        }
    }

    private resetTokenConnect(state:ConcDetailModelState):void {
        state.tokenConnectData = {
            token: null,
            renders: []
        };
    }

    private generateSpeechesDetail(state:ConcDetailModelState):SpeechLines {

        const parseTag = (name:string, s:string):{[key:string]:string} => {
            const srch = new RegExp(`<${name}(\\s+[^>]+)>`).exec(s);
            if (srch) {
                const ans:{[key:string]:string} = {};
                const items = srch[1].trim()
                    .split(new RegExp(`([${ConcDetailModel.ATTR_NAME_ALLOWED_CHARS}]+)=`)).slice(1);
                for (let i = 0; i < items.length; i += 2) {
                        ans[items[i]] = (items[i+1] || '').trim();
                }
                return ans;
            }
            return null;
        };

        const createNewSpeech = (speakerId:string, colorCode:Color.RGBA,
                    metadata:{[attr:string]:string}):Speech => {
            const importedMetadata = pipe(
                metadata,
                Dict.filter((val, attr) => attr !== state.speechOpts.speechSegment[1] &&
                                attr !== state.speechOpts.speakerIdAttr[1]),
            );
            return {
                text: [],
                speakerId,
                segments: [],
                metadata: importedMetadata,
                colorCode
            };
        };

        const isFullOverlap = (s1:Speech, s2:Speech):boolean => {
            if (s1 && s2 && state.spkOverlapMode === ConcDetailModel.SPK_OVERLAP_MODE_FULL) {
                const flag1 = state.speechOpts.speechOverlapAttr ?
                        s1.metadata[state.speechOpts.speechOverlapAttr[1]] :
                        '';
                const flag2 = state.speechOpts.speechOverlapAttr ?
                        s2.metadata[state.speechOpts.speechOverlapAttr[1]] :
                        '';
                if (flag1 === flag2
                        && flag2 === state.speechOpts.speechOverlapVal
                        && s1.segments[0] === s2.segments[0]) {
                    return true;
                }
            }
            return false;
        };

        const mergeOverlaps = (speeches:Array<Speech>):SpeechLines => {
            const ans:SpeechLines = [];
            let prevSpeech:Speech = null;
            speeches.forEach((item, i) => {
                if (isFullOverlap(prevSpeech, item)) {
                    ans[ans.length - 1].push(item);
                    ans[ans.length - 1] = ans[ans.length - 1].sort((s1, s2) => {
                        if (s1.speakerId > s2.speakerId) {
                            return 1;

                        } else if (s1.speakerId < s2.speakerId) {
                            return -1;

                        } else {
                            return 0;
                        }
                    });

                } else {
                    ans.push([item]);
                }
                prevSpeech = item;
            });
            return ans;
        };

        let currSpeech:Speech = createNewSpeech('\u2026', null, {});
        let prevSpeech:Speech = null;
        const tmp:Array<Speech> = [];

        (state.concDetail || []).forEach((item, i) => {
            if (item.class === 'strc') {
                const attrs = parseTag(state.speechOpts.speakerIdAttr[0], item.str);
                if (attrs !== null && attrs[state.speechOpts.speakerIdAttr[1]]) {
                        tmp.push(currSpeech);
                        const newSpeakerId = attrs[state.speechOpts.speakerIdAttr[1]];
                        if (!Dict.hasKey(newSpeakerId, state.speakerColorsAttachments)) {
                            state.speakerColorsAttachments[newSpeakerId] =
                                state.speakerColors[Dict.size(
                                    state.speakerColorsAttachments)]
                        }
                        prevSpeech = currSpeech;
                        currSpeech = createNewSpeech(
                            newSpeakerId,
                            state.speakerColorsAttachments[newSpeakerId],
                            attrs
                        );
                }
                if (item.str.indexOf(`<${state.speechOpts.speechSegment[0]}`) > -1) {
                    const attrs = parseTag(state.speechOpts.speechSegment[0], item.str);
                    if (attrs) {
                        currSpeech.segments.push(attrs[state.speechOpts.speechSegment[1]]);
                    }

                }
                if (state.spkOverlapMode === ConcDetailModel.SPK_OVERLAP_MODE_SIMPLE
                            && state.speechOpts.speechOverlapAttr) {
                    const overlapSrch = new RegExp(
                        `</?(${state.speechOpts.speechOverlapAttr[0]})(>|[^>]+>)`, 'g');
                    let srch = overlapSrch.exec(item.str);
                    let i = 0;
                    while (srch !== null) {
                        if (srch[0].indexOf('</') === 0
                                && item.str.indexOf(
                                    `<${state.speechOpts.speakerIdAttr[0]}`) > 0) {
                            prevSpeech.text.push({str: srch[0], class: item.class});

                        } else {
                            currSpeech.text.push({str: srch[0], class: item.class});
                        }
                        i += 1;
                        srch = overlapSrch.exec(item.str);
                    }
                }

            } else {
                currSpeech.text.push({
                    str: item.str,
                    class: item.class
                });
            }
        });
        if (currSpeech.text.length > 0) {
            tmp.push(currSpeech);
        }
        return mergeOverlaps(tmp);
    }

    /**
     *
     */
    private loadWholeDocument():Observable<any> {
        // TODO if mode speeches or a custom one, throw an error here
        return this.layoutModel.ajax$<WideCtx>(
            HTTP.Method.GET,
            this.layoutModel.createActionUrl('structctx'),
            {
                corpname: this.state.corpusId,
                pos: this.state.kwicTokenNum,
                struct: this.state.structCtx
            },
            {}

        ).pipe(
            tap(
                (data) => {
                    this.state.concDetail = data.content;
                    this.state.wholeDocumentLoaded = true;
                    this.state.expandLeftArgs = [];
                    this.state.expandRightArgs = [];
                }
            )
        );
    }

    /**
     *
     */
    private loadSpeechDetail(expand?:'left'|'right'|'reload'):Observable<boolean> {
        const structs = this.layoutModel.getConcArgs().structs;
        const args = pipe(
                this.state.speechAttrs,
                List.map(x => `${this.state.speechOpts.speakerIdAttr[0]}.${x}`),
                List.concat([this.state.speechOpts.speechSegment.join('.')])
        );
        const [overlapStruct, overlapAttr] = (this.state.speechOpts.speechOverlapAttr ||
                [undefined, undefined]);
        if (overlapStruct !== this.state.speechOpts.speakerIdAttr[0]
                && structs.indexOf(overlapStruct) === -1) {
            if (overlapStruct && overlapAttr) {
                args.push(`${overlapStruct}.${overlapAttr}`);

            } else if (overlapStruct) {
                args.push(overlapStruct);
            }
        }
        return this.loadConcDetail(args, expand);
    }

    private loadTokenConnect(corpusId:string, tokenNum:number, numTokens:number,
            lineIdx:number, expand:'left'|'right'|'reload'):Observable<boolean> {
        const [expand_left_args, expand_right_args] = this.getExpandArgs(expand);
        return this.tokenConnectPlg.fetchTokenConnect(
            corpusId,
            tokenNum,
            numTokens,
            tuple(expand_left_args, expand_right_args)

        ).pipe(
            tap(
                (data) => {
                    if (data) {
                        this.changeState(state => {
                            state.tokenConnectData = data;
                            state.lineIdx = lineIdx;
                        });
                    }
                }
            ),
            map(
                data => !!data
            )
        );
    }

    private getExpandArgs(expand:'left'|'right'|'reload'):[number, number]|[undefined, undefined] {
        switch(expand) {
            case 'left':
                return List.get(-1, this.state.expandLeftArgs);
            case 'right':
                return List.get(-1, this.state.expandRightArgs);
            case 'reload':
                if (this.state.expandLeftArgs.length > 1 &&
                        this.state.expandRightArgs.length > 1) {
                    return tuple(
                        List.get(-1, this.state.expandRightArgs)[0],
                        List.get(-1, this.state.expandLeftArgs)[1]
                    );
                }
            default:
                return tuple(undefined, undefined);
        }
    }

    /**
     *
     */
    private loadConcDetail(structs:Array<string>, expand?:'left'|'right'|'reload'):Observable<boolean> {
        const [lft, rgt] = this.getExpandArgs(expand);
        const args = {
            ...this.state.wideCtxGlobals,
            corpname: this.state.corpusId, // just for sure (is should be already in args)
            // we must delete 'usesubcorp' as the server API does not need it
            // and in case of an aligned corpus it even produces an error
            usesubcorp: undefined,
            pos: this.state.kwicTokenNum,
            detail_left_ctx: lft,
            detail_right_ctx: rgt,
            format: 'json'
        };
        if (this.state.kwicLength && this.state.kwicLength > 1) {
            args.hitlen = this.state.kwicLength;
        }
        if (structs) {
            args.structs = args.structs.concat(structs);
        }

        return this.layoutModel.ajax$<WideCtx>(
            HTTP.Method.GET,
            this.layoutModel.createActionUrl('widectx'),
            args,
            {}

        ).pipe(
            tap(
                (data) => {
                    this.changeState(state => {
                        state.concDetail = data.content;
                        if (state.mode === 'speech') {
                            state.speechDetail = this.generateSpeechesDetail(state);
                        }
                        if (data.expand_left_args) {
                            state.expandLeftArgs.push([
                                data.expand_left_args.detail_left_ctx,
                                data.expand_left_args.detail_right_ctx
                            ]);

                        } else {
                            state.expandLeftArgs.push(tuple(undefined, undefined));
                        }
                        if (data.expand_right_args) {
                            state.expandRightArgs.push([
                                data.expand_right_args.detail_left_ctx,
                                data.expand_right_args.detail_right_ctx
                            ]);

                        } else {
                            state.expandRightArgs.push(tuple(undefined, undefined));
                        }
                    });
                }
            ),
            map(d =>  !!d)
        );
    }

    private reloadConcDetail():Observable<boolean> {
        return this.loadConcDetail([], 'reload');
    }

    static hasExpandLeft(state:ConcDetailModelState):boolean {
        const [lft, rgt] = List.empty(state.expandLeftArgs) ?
                [undefined, undefined] : List.get(-1, state.expandLeftArgs);
        return lft !== undefined && rgt !== undefined;
    }

    static hasExpandRight(state:ConcDetailModelState):boolean {
        const [lft, rgt] = List.empty(state.expandLeftArgs) ?
                [undefined, undefined] : List.get(-1, state.expandRightArgs);
        return lft !== undefined && rgt !== undefined;
    }

    static canDisplayWholeDocument(state:ConcDetailModelState):boolean {
        return state.structCtx && !state.wholeDocumentLoaded;
    }

    supportsTokenConnect():boolean {
        return this.tokenConnectPlg.isActive() && this.tokenConnectPlg.providesAnyTokenInfo();
    }

    static supportsSpeechView(state:ConcDetailModelState):boolean {
        return !!state.speechOpts.speakerIdAttr;
    }

    private handlePlayerControls(action:AudioPlayerActions) {
        switch (action) {
            case 'play':
                this.audioPlayer.play();
                this.changeState(state => {
                    state.audioPlayerStatus = this.audioPlayer.getStatus();
                });
            break;
            case 'pause':
                this.audioPlayer.pause();
                this.changeState(state => {
                    state.audioPlayerStatus = this.audioPlayer.getStatus();
                });
            break;
            case 'stop':
                this.changeState(state => {
                    state.playingRowIdx = null;
                    state.audioPlayerStatus = null;
                });
                this.audioPlayer.stop();
            break;
        }
    }
}

